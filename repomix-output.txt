This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-01T23:44:30.020Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
bin/
  jy-validator.js
src/
  validator.js
tests/
  jy-validator.test.js
LICENSE
package.json
README.md

================================================================
Files
================================================================

================
File: bin/jy-validator.js
================
#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import { validateFile } from '../src/validator.js';

const program = new Command();

program
    .name('jy-validator')
    .description('CLI tool to validate JSON and YAML files')
    .version('1.0.0')
    .argument('<file>', 'file to validate')
    .option('-t, --type <type>', 'force specific format type (json/yaml)')
    .action(async (file, options) => {
        try {
            if (options.type && !['json', 'yaml'].includes(options.type.toLowerCase())) {
                console.error(chalk.red('Error: Type must be either "json" or "yaml"'));
                process.exit(1);
            }

            const result = await validateFile(file, options.type?.toLowerCase());
            console.log(chalk.green(`âœ“ Valid ${result.type.toUpperCase()}`));

        } catch (error) {
            console.error(chalk.red(`Error: ${error.message}`));
            process.exit(1);
        }
    });

program.parse();

================
File: src/validator.js
================
import fs from 'fs/promises';
import yaml from 'js-yaml';
import path from 'path';

const SUPPORTED_EXTENSIONS = {
    '.json': 'json',
    '.yaml': 'yaml',
    '.yml': 'yaml'
};

const validateFile = async (filePath, forcedType = null) => {
    const extension = path.extname(filePath).toLowerCase();
    const fileType = forcedType || SUPPORTED_EXTENSIONS[extension];

    if (!fileType) {
        throw new Error(`Unsupported file extension: ${extension}. Supported extensions are: .json, .yaml, .yml`);
    }

    try {
        const content = await fs.readFile(filePath, 'utf8');

        if (fileType === 'json') {
            try {
                JSON.parse(content);
                return {
                    isValid: true,
                    type: 'json'
                };
            } catch (error) {
                throw new Error(`Invalid JSON: ${error.message}`);
            }
        }

        if (fileType === 'yaml') {
            try {
                yaml.load(content);
                return {
                    isValid: true,
                    type: 'yaml'
                };
            } catch (error) {
                throw new Error(`Invalid YAML: ${error.message}`);
            }
        }

    } catch (error) {
        if (error.code === 'ENOENT') {
            throw new Error(`File not found: ${filePath}`);
        }
        throw error;
    }
};

export { validateFile };

================
File: tests/jy-validator.test.js
================
import { jest } from '@jest/globals';
import { validateFile } from '../src/validator.js';

const mockReadFile = jest.fn();

jest.unstable_mockModule('fs/promises', () => ({
    default: {
        readFile: mockReadFile
    }
}));

describe('JY Validator', () => {
    const validJson = '{"name": "test", "value": 123}';
    const invalidJson = '{"name": "test", value: 123}';
    const validYaml = 'name: test\nvalue: 123';
    const invalidYaml = 'name: test\n  value: : 123';

    beforeEach(() => {
        mockReadFile.mockReset();
    });

    test('rejects unsupported file extensions', async () => {
        await expect(validateFile('test/file.txt')).rejects.toThrow('Unsupported file extension');
    });

    test('accepts .yml extension for yaml files', async () => {
        mockReadFile.mockResolvedValue(validYaml);
        const result = await validateFile('test/valid.yml');
        expect(result).toEqual({ isValid: true, type: 'yaml' });
    });

    test('validates JSON successfully', async () => {
        mockReadFile.mockResolvedValue(validJson);
        const result = await validateFile('test/valid.json');
        expect(result).toEqual({ isValid: true, type: 'json' });
    });

    test('fails on invalid JSON with specific error', async () => {
        mockReadFile.mockResolvedValue(invalidJson);
        await expect(validateFile('test/invalid.json')).rejects.toThrow('Invalid JSON');
    });

    test('validates YAML successfully', async () => {
        mockReadFile.mockResolvedValue(validYaml);
        const result = await validateFile('test/valid.yaml');
        expect(result).toEqual({ isValid: true, type: 'yaml' });
    });

    test('fails on invalid YAML with specific error', async () => {
        mockReadFile.mockResolvedValue(invalidYaml);
        await expect(validateFile('test/invalid.yaml')).rejects.toThrow('Invalid YAML');
    });

    test('respects forced JSON type', async () => {
        mockReadFile.mockResolvedValue(validJson);
        const result = await validateFile('test/file.txt', 'json');
        expect(result).toEqual({ isValid: true, type: 'json' });
    });

    test('handles file not found error', async () => {
        mockReadFile.mockRejectedValue({ code: 'ENOENT' });
        await expect(validateFile('nonexistent.json')).rejects.toThrow('File not found');
    });
});

================
File: LICENSE
================
MIT License

Copyright (c) 2025 John Seong

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "jy-validator",
  "version": "1.0.0",
  "description": "CLI tool to validate JSON and YAML files",
  "main": "src/validator.js",
  "type": "module",
  "bin": {
    "jy-validator": "./bin/jy-validator.js"
  },
  "scripts": {
    "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js"
  },
  "keywords": [
    "cli",
    "json",
    "yaml",
    "validator",
    "format",
    "jy-validator"
  ],
  "author": {
    "name": "John Seong",
    "url": "https://github.com/sandole"
  },
  "license": "MIT",
  "dependencies": {
    "chalk": "^5.3.0",
    "commander": "^11.0.0",
    "js-yaml": "^4.1.0"
  },
  "devDependencies": {
    "jest": "^29.7.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sandole/jy-validator.git"
  },
  "bugs": {
    "url": "https://github.com/sandole/jy-validator/issues"
  },
  "homepage": "https://github.com/sandole/jy-validator#readme",
  "engines": {
    "node": ">=14.0.0"
  },
  "jest": {
    "transform": {},
    "testEnvironment": "node"
  }
}

================
File: README.md
================
A simple CLI tool to validate JSON and YAML files.

## Installation

```bash
npm install -g jy-validator
```

## Usage

```bash
# Validate a JSON file
jy-validator example.json

# Validate a YAML file
jy-validator example.yaml

# Force specific format type
jy-validator example.txt -t json
jy-validator example.txt -t yaml
```

## Features

- Validates JSON and YAML files
- Automatic format detection based on file extension
- Manual format override with `-t` flag
- Clear error messages
- Colorized output

## License

MIT
